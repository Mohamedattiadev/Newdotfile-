#!/usr/bin/env bash
#
# Script name: ILovePDF Mini Files
# Description: Hierarchical file browser for iLovePDF-style conversions
# Dependencies: rofi, zenity, libreoffice, imagemagick, ghostscript, poppler-utils (for pdfinfo)
# License: MIT

set -euo pipefail

# --- Configuration ---
BASE_DIR=~/ILovePdf_Style_Docs
ROFI_CMD="rofi -dmenu -i -p"
SEPARATOR="ÓÇ∞"

# Main directories to browse.
declare -A MAIN_DIR_MAP
MAIN_DIR_MAP["Documents"]="$HOME/Documents"
MAIN_DIR_MAP["Downloads"]="$HOME/Downloads"
MAIN_DIR_MAP["Pictures"]="$HOME/Pictures"
MAIN_DIR_MAP["Desktop"]="$HOME/Desktop"

# --- Main Logic in a function ---
main() {
	# --- Actions Menu ---
	local ACTIONS="Word ‚Üí PDF
PDF ‚Üí Word
Excel ‚Üí PDF
PowerPoint ‚Üí PDF
PDF ‚Üí JPG
PDF ‚Üí PNG
JPG ‚Üí PDF
PNG ‚Üí PDF
Compress PDF
Resize Image
Merge PDFs
Split PDF"

	# 1. Select action from the menu
	local ACTION
	ACTION=$(echo -e "$ACTIONS" | $ROFI_CMD "Select Action") || exit 0

	# 2. Define allowed file extensions based on action
	local EXT=""
	local MULTI_SELECT="false"
	case "$ACTION" in
	"Word ‚Üí PDF") EXT="docx" ;;
	"PDF ‚Üí Word") EXT="pdf" ;;
	"Excel ‚Üí PDF") EXT="xlsx" ;;
	"PowerPoint ‚Üí PDF") EXT="pptx" ;;
	"PDF ‚Üí JPG" | "PDF ‚Üí PNG") EXT="pdf" ;;
	"JPG ‚Üí PDF") EXT="jpg jpeg" ;;
	"PNG ‚Üí PDF") EXT="png" ;;
	"Compress PDF" | "Split PDF") EXT="pdf" ;;
	"Resize Image") EXT="jpg jpeg png gif bmp" ;;
	"Merge PDFs")
		EXT="pdf"
		MULTI_SELECT="true"
		;;
	*)
		echo "Unknown action: $ACTION"
		exit 1
		;;
	esac
	local EXT_ARRAY=($EXT)

	# 3. Main application loop for directory/file selection
	while true; do
		SELECTED_FILES=() # Reset selected files array for each loop

		local main_menu_options=("${!MAIN_DIR_MAP[@]}")

		local DIR_CHOICE
		DIR_CHOICE=$(printf '%s\n' "${main_menu_options[@]}" | sort | $ROFI_CMD "Select Starting Directory") || exit 0

		local CURRENT_DIR="${MAIN_DIR_MAP[$DIR_CHOICE]}"

		# Navigate and select files. This function returns 0 on success (file selected), 1 on "go home".
		if navigate "$CURRENT_DIR" "$ACTION" "$MULTI_SELECT" "${EXT_ARRAY[@]}"; then
			# If a file was selected (returns 0), break the loop to proceed with conversion
			break
		else
			# If user chose "Main Menu" or cancelled from top (returns 1), loop continues
			continue
		fi
	done

	# 4. Prepare output folder and perform the action
	local OUT_DIR="$BASE_DIR/$ACTION"
	mkdir -p "$OUT_DIR"

	local FIRST_FILE="${SELECTED_FILES[0]}"
	local FILENAME=$(basename "$FIRST_FILE")
	local NAME="${FILENAME%.*}"

	case "$ACTION" in
	"Word ‚Üí PDF" | "Excel ‚Üí PDF" | "PowerPoint ‚Üí PDF")
		libreoffice --headless --convert-to pdf "$FIRST_FILE" --outdir "$OUT_DIR"
		;;
	"PDF ‚Üí Word")
		libreoffice --headless --convert-to docx "$FIRST_FILE" --outdir "$OUT_DIR"
		;;
	"JPG ‚Üí PDF" | "PNG ‚Üí PDF")
		convert "$FIRST_FILE" "$OUT_DIR/${NAME}.pdf"
		;;
	"PDF ‚Üí JPG")
		convert -density 150 "$FIRST_FILE" "$OUT_DIR/${NAME}_%03d.jpg"
		;;
	"PDF ‚Üí PNG")
		convert -density 150 "$FIRST_FILE" "$OUT_DIR/${NAME}_%03d.png"
		;;
	"Compress PDF")
		gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen \
			-dNOPAUSE -dBATCH -sOutputFile="$OUT_DIR/${NAME}_compressed.pdf" "$FIRST_FILE"
		;;
	"Resize Image")
		local SIZE
		SIZE=$(zenity --entry --title="Resize Image" --text="Enter new size (e.g., 50% or 800x600)") || exit 1
		convert "$FIRST_FILE" -resize "$SIZE" "$OUT_DIR/${NAME}_resized.${FIRST_FILE##*.}"
		;;
	"Merge PDFs")
		local OUTPUT_FILENAME="${NAME}_merged.pdf"
		gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$OUT_DIR/$OUTPUT_FILENAME" "${SELECTED_FILES[@]}"
		;;
	"Split PDF")
		local PAGES
		PAGES=$(pdfinfo "$FIRST_FILE" | grep "Pages:" | awk '{print $2}')
		if ! [[ "$PAGES" =~ ^[0-9]+$ ]]; then
			notify-send "ILovePDF Error" "Could not determine page count for $FILENAME"
			exit 1
		fi
		for ((i = 1; i <= PAGES; i++)); do
			gs -sDEVICE=pdfwrite -dBATCH -dNOPAUSE -dFirstPage=$i -dLastPage=$i \
				-sOutputFile="$OUT_DIR/${NAME}_page_$i.pdf" "$FIRST_FILE"
		done
		;;
	esac

	notify-send "ILovePDF" "$ACTION completed for '$FILENAME'. Check $OUT_DIR"
}

# This global is populated by the navigate function
SELECTED_FILES=()
navigate() {
	local current_dir="$1"
	local action="$2"
	local multi_select="$3"
	shift 3
	local ext_array=("$@")

	local navigation_stack=()
	local rofi_options=""
	[[ "$multi_select" == "true" ]] && rofi_options="-multi-select"

	while true; do
		local ENTRIES=() DIRS=() FILES=()

		# Find non-hidden directories
		while IFS= read -r -d '' d; do
			local dirname
			dirname=$(basename "$d")
			[[ "$dirname" == .* ]] && continue # Hide dot folders
			DIRS+=("$dirname/")
		done < <(find "$current_dir" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null | sort -z)

		# Find non-hidden files with the right extension
		while IFS= read -r -d '' f; do
			local filename
			filename=$(basename "$f")
			[[ "$filename" == .* ]] && continue # Hide dot files
			local file_ext="${f##*.}"
			for e in "${ext_array[@]}"; do
				if [[ "${file_ext,,}" == "$e" ]]; then
					FILES+=("$filename")
					break
				fi
			done
		done < <(find "$current_dir" -mindepth 1 -maxdepth 1 -type f -print0 2>/dev/null | sort -z)

		ENTRIES=("${DIRS[@]}" "${FILES[@]}")

		# Add navigation options to the top of the menu
		ENTRIES=("üè† Main Menu" "${ENTRIES[@]}")
		if ! printf '%s\n' "${MAIN_DIR_MAP[@]}" | grep -q "^${current_dir}$"; then
			ENTRIES=("../" "${ENTRIES[@]}")
		fi

		local REL_PATH="${current_dir#$HOME/}"
		local choice
		choice=$(printf '%s\n' "${ENTRIES[@]}" | $ROFI_CMD $rofi_options "$action ${SEPARATOR} ${REL_PATH}")

		if [[ -z "$choice" ]]; then                                # User pressed Esc
			if [[ ${#navigation_stack[@]} -eq 0 ]]; then return 1; fi # At top level, go to Main Menu
			current_dir="${navigation_stack[-1]}"
			unset 'navigation_stack[${#navigation_stack[@]}-1]'
		elif [[ "$choice" == "üè† Main Menu" ]]; then
			return 1 # Signal to go back to the main directory menu
		elif [[ "$choice" == "../" ]]; then
			current_dir="$(dirname "$current_dir")"
		elif [[ "$choice" == */ ]]; then
			navigation_stack+=("$current_dir")
			current_dir="$current_dir/${choice%/}"
		else
			mapfile -t choices < <(echo -e "$choice")
			for item in "${choices[@]}"; do
				SELECTED_FILES+=("$current_dir/$item")
			done
			return 0 # Signal success, file was selected
		fi
	done
}

# --- Script Entry Point ---
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
