#!/usr/bin/env python
# -*- coding: utf-8 -*-

import ast
import os
import subprocess

# --- Configuration ---
CONFIG_FILE = os.path.expanduser("~/.config/qtile/config.py")

MOD_SYMBOLS = {
    "mod": "MOD",
    "mod1": "MOD",
    "mod2": "WIN",
    "mod4": "WIN",
    "shift": "SHIFT",
    "control": "CTRL",
}

# --- AST-based Parser ---

class KeybindingVisitor(ast.NodeVisitor):
    """
    An AST visitor that intelligently finds and formats described keybindings.
    """
    def __init__(self):
        self.keybindings = []
        # This will now store the full prefix, e.g., ["MOD + p →"]
        self._prefix_stack = []

    def _format_mods(self, mods_list_node):
        """Safely formats the modifiers from an AST list node."""
        mods = [m.id if isinstance(m, ast.Name) else m.value for m in mods_list_node.elts]
        return [MOD_SYMBOLS.get(m, m.upper()) for m in mods]

    def _format_desc(self, keywords):
        """
        Safely formats the description, returning None if not found.
        Intelligently handles .format() calls.
        """
        for keyword in keywords:
            if keyword.arg == 'desc':
                if isinstance(keyword.value, ast.Constant):
                    return keyword.value.value  # It's a simple string
                # Check for "string".format()
                if (isinstance(keyword.value, ast.Call) and
                    isinstance(keyword.value.func, ast.Attribute) and
                    keyword.value.func.attr == 'format' and
                    isinstance(keyword.value.func.value, ast.Constant)):
                    # Return the cleaner base string
                    return keyword.value.func.value.value
                # Fallback for other complex descriptions
                return ast.unparse(keyword.value)
        return None # No description found

    def visit_Call(self, node):
        """
        This method is called for every function call in the code.
        We check if it's a Key or KeyChord.
        """
        if not hasattr(node.func, 'id'):
            self.generic_visit(node)
            return

        key_type = node.func.id
        if key_type not in ('Key', 'KeyChord'):
            self.generic_visit(node)
            return

        desc = self._format_desc(node.keywords)
        
        # --- MASTERPIECE RULE 1: If no description, ignore it completely. ---
        if desc is None and key_type != 'KeyChord':
             return # Skip this key

        mods = self._format_mods(node.args[0])
        key = node.args[1].value
        
        # Build the full key combination string
        prefix = "".join(self._prefix_stack)
        mod_str = " + ".join(mods)
        combo = " + ".join(filter(None, [prefix, mod_str, key]))

        if key_type == 'KeyChord':
            # If the chord itself has a description, show it.
            if desc:
                self.keybindings.append((combo, f"{desc} (CHORD)"))
            
            # --- MASTERPIECE RULE 2: Use a full, clear prefix for sub-keys. ---
            self._prefix_stack.append(f"{' + '.join(filter(None, [mod_str, key]))} → ")
            # Visit the sub-keys defined in the chord's list
            if len(node.args) > 2 and isinstance(node.args[2], ast.List):
                 self.generic_visit(node.args[2])
            self._prefix_stack.pop()
        else: # It's a regular Key
             self.keybindings.append((combo, desc))


def parse_keys_ast(config_path):
    """
    Parses the Qtile config using AST to find all described keybindings.
    """
    try:
        with open(config_path, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception as e:
        print(f"Error reading config file: {e}")
        return []
    
    try:
        tree = ast.parse(content)
        # We only need to visit the `keys` list assignment and extensions
        key_defs = []
        for body_item in tree.body:
            # Find `keys = [...]`
            if (isinstance(body_item, ast.Assign) and
                isinstance(body_item.targets[0], ast.Name) and
                body_item.targets[0].id == 'keys'):
                key_defs.append(body_item)
            # Find `keys.extend([...])`
            if (isinstance(body_item, ast.Expr) and
                isinstance(body_item.value, ast.Call) and
                hasattr(body_item.value.func, "value") and
                isinstance(body_item.value.func.value, ast.Name) and
                body_item.value.func.value.id == 'keys'):
                key_defs.append(body_item)

        visitor = KeybindingVisitor()
        for node in key_defs:
            visitor.visit(node)
            
        return visitor.keybindings
    except SyntaxError as e:
        print(f"Error parsing config file syntax: {e}")
        return []

def format_and_show(keybindings):
    """
    Formats the keybindings and displays them using Rofi.
    """
    if not keybindings:
        subprocess.run(['notify-send', "Keymap Previewer", "No described keybindings found."])
        return

    # Sort keybindings for consistency, chords first
    keybindings.sort(key=lambda k: (k[0].count('→'), k[0]))

    formatted_lines = [f"{combo.ljust(40)}: {desc}" for combo, desc in keybindings]
    
    rofi_command = [
        "rofi", "-dmenu", "-i", "-p", "Keybindings",
        "-mesg", "Search your described Qtile keybindings",
        "-theme-str", 'window {width: 50%;}',
        "-theme-str", 'listview {lines: 10;}'
    ]

    rofi_process = subprocess.Popen(rofi_command, stdin=subprocess.PIPE, text=True, encoding="utf-8")
    rofi_process.communicate("\n".join(formatted_lines))


if __name__ == "__main__":
    bindings = parse_keys_ast(CONFIG_FILE)
    format_and_show(bindings)
